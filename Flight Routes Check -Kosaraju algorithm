#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i, st, ed) for (int i = st; i < ed; i++)

// SUBPROBLEM (flight route check)
// --1. if path is possible from every node to every other node(directed )
// -- options bellman ford(tle)
// --2. if there is something like component then answer will  be no -->
// will also not give answer (test case 1->2 1->3 then it will give answe)
// 3. if there is anything in a cycle then any pair inside the cycle cannot be our answer
// 4. kosaraju fro strongly connected component ✔️

void topological_order(vector<int> adj[], vector<int> &vis, int node, stack<int> &st)
{
    vis[node] = 1;
    for (int &adjnode : adj[node])
    {
        if (vis[adjnode] == 0)
            topological_order(adj, vis, adjnode, st);
    }
    st.push(node);
}

void dfs(vector<int> adj[], vector<int> &vis, int node)
{
    vis[node] = 1;
    for (int &adjnode : adj[node])
    {
        if (vis[adjnode] == 0)
            dfs(adj, vis, adjnode);
    }
}

int main()
{
    int n, m;
    cin >> n >> m;
    vector<int> adj[n + 1];
    vector<int> adjRev[n + 1];
    while (m--)
    {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        //   along with that also store reverse of graph
        adjRev[v].push_back(u);
    }
    // storing in topological order
    stack<int> topo;
    vector<int> vis(n + 1);
    int cnt = 0;
    int prev = 0;

    for (int i = 1; i <= n; i++)
    {
        if (vis[i] == 0)
        {
            // While storing topological order also search if there is more than one component
            if (cnt == 1)
            {
                cout << "NO\n";
                cout << prev << " " << i << endl;
                return 0;
            }
            cnt++;
            topological_order(adj, vis, i, topo);
            prev = i;
        }
    }

    for (int i = 1; i <= n; i++)
        vis[i] = 0;

    cnt = 0;
    prev = 0;
    // perform dfs on th basis of topological order on reverse graph
    while (topo.empty() == false)
    {
        int node = topo.top();
        topo.pop();
        if (vis[node] == 0)
        {
            // if there is more than one component then
            if (cnt == 1)
            {
                cout << "NO\n"
                     << node << " " << prev << endl;
                return 0;
            }
            dfs(adjRev, vis, node);
            cnt++;
            prev = node;
        }
    }

    cout << "YES\n";
}
