#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i, st, ed) for (int i = st; i < ed; i++)
// Subproblem
// -- we need to find shortest path ---> dijkstra
// -- we need all k shortest path --> slight modification we need to keep track of all the kt
//    shortest path

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    ll n, m, k;
    cin >> n >> m >> k;

    vector<pair<ll, ll>> adj[n + 1];

    while (m--)
    {
        ll u, v, wt;
        cin >> u >> v >> wt;
        adj[u].push_back({v, wt});
    }

    // keep track of all the k distance for all the nodes
    vector<vector<ll>> dist(n + 1, vector<ll>(k, 1e17));

    priority_queue<
        pair<ll, ll>,
        vector<pair<ll, ll>>,
        greater<pair<ll, ll>>>
        pq;
    pq.push({0, 1});

    while (pq.empty() == false)
    {
        ll cost = pq.top().first;
        ll u = pq.top().second;
        pq.pop();

        // if that cost does not affect our solution then move on
        if (dist[u][k - 1] < cost)
            continue;

        for (auto itr : adj[u])
        {
            // compare with the highest cost
            if (dist[itr.first][k - 1] > cost + itr.second)
            {
                dist[itr.first][k - 1] = cost + itr.second;
                pq.push({dist[itr.first][k - 1], itr.first});
                // sort- so that we can get in ordered way
                sort(dist[itr.first].begin(), dist[itr.first].end());
            }
        }
    }

    for (ll &cost : dist[n])
    {
        cout << cost << " ";
    }
    cout << endl;
}
